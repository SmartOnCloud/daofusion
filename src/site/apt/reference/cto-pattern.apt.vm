 ----
 Criteria transfer object pattern
 ----
 Vojtech Szocs
 ----
 18 March 2009
 ----

Criteria transfer object pattern
  
  Use the criteria transfer object (CTO) pattern to construct client-side versions of persistent entity criteria instances and pass them through the chosen communication mechanism
  to the remote server-side component, employing a CTO converter for seamless CTO-to-criteria transformation.
  
Sections
  
  * {{{./cto-pattern.html#Overview} Overview}}
  
  * {{{./cto-pattern.html#Introduction} Introduction}}
  
  * {{{./cto-pattern.html#CTO_class_overview_client} CTO class overview (client)}}
  
  * {{{./cto-pattern.html#CTO_class_overview_server} CTO class overview (server)}}
  
  * {{{./cto-pattern.html#Sample_CTO_converter} Sample CTO converter}}
  
  * {{{./cto-pattern.html#FAQ} FAQ}}
  
  []
  
External resources
  
  * {{{http://java.sun.com/blueprints/corej2eepatterns/Patterns/TransferObject.html} Transfer object pattern}}
  
  []
  
* {Overview}
  
  * Project: <${df-core}>
  
  * Package reference: <<<com.anasoft.os.daofusion.cto.*>>>
  
* {Introduction}
  
  Even though the criteria transfer object (CTO) pattern might sound like a buzzword, it's actually a concept that aims for application scenarios with loose coupling between the client
  and the server. The primary goal here is to enable clients to construct <serializable> versions of persistent entity criteria instances (criteria transfer objects) and pass them through
  the chosen communication mechanism to remote components which can convert them into <<<PersistentEntityCriteria>>> seamlessly.
  
  Using this concept, building complex data grids that use filtering, sorting and paging functionality can be accomplished in a very easy way, assuming that:
  
  * GUI changes within grid elements (filter value widgets, sorted column headers, paging options, etc.) will change the corresponding CTO accordingly
  
  * data refresh operation will pass the CTO as an argument of a remote method call using the chosen communication mechanism, receiving requested results and populating the data grid thereafter
  
  []
  
  Besides standard Java based client-server application scenarios, the CTO pattern proves to be useful within the world of {{{http://en.wikipedia.org/wiki/Rich_Internet_application} RIA}}
  (rich internet application) technologies such as {{{http://code.google.com/webtoolkit/} Google Web Toolkit}} or {{{http://www.adobe.com/products/flex/} Flex}}. In general, any client technology
  that allows direct or indirect modification of the Java based CTO instance can benefit from the CTO pattern.
  
  One important thing to note here is that the CTO pattern defines client-side persistent entity criteria transfer object model along with its server-side processing (the "request"
  part of the client-server communication). CTO pattern does NOT define "response" the server-side component should produce after retrieving results based on converted CTO instance
  - this is a task left to the developer based on the {{{http://java.sun.com/blueprints/corej2eepatterns/Patterns/TransferObject.html} transfer object}} strategy for the given project.
  
* {CTO class overview (client)}
  
  <<<CriteriaTransferObject>>> represents a generic CTO class containing persistent entity criteria as well as the paging specification. <<<CriteriaTransferObject>>> acts as a map-based container
  for <<<FilterAndSortCriteria>>> instances (the key is the <propertyId> of the given <<<FilterAndSortCriteria>>> instance). This means that all <<<FilterAndSortCriteria>>> instances must have unique
  <propertyId>'s within the same transfer object.
  
  <<<FilterAndSortCriteria>>> defines basic filter and sort criteria for a single property of the target persistent entity. This class is essentially an analogy of server-side <<<FilterCriterion>>>
  and <<<SortCriterion>>> classes combined together in a simple client-side implementation. The <propertyId> mentioned above is a symbolic persistent entity property identifier which is resolved
  into the corresponding <propertyPath> back on the server via the CTO converter. <<<FilterAndSortCriteria>>> handles filter values as simple strings to avoid client-side type conversions,
  making things a bit more generic. Same as the <propertyId>, all filter values are converted into their typed object representations (integers, dates, etc.) during the CTO conversion
  process. Note that it is common to pass multiple filter values to a single <<<FilterAndSortCriteria>>> instance - a good example would be a date property of an entity which needs to fall
  between two boundary values.
  
  Note that it is important to bind GUI changes within grid elements (filter value widgets, sorted column headers, paging options, etc.) to the associated CTO instance, for example:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/cto-pattern-CriteriaTransferObjectUsage.java}
  
  These two simple classes conclude the client part of the CTO pattern.
  
* {CTO class overview (server)}
  
  <<<CriteriaTransferObjectConverter>>> interface represents the general CTO converter contract defining conversion pattern between <<<CriteriaTransferObject>>> instances and their corresponding
  <<<PersistentEntityCriteria>>> counterparts:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/cto-pattern-CriteriaTransferObjectConverter.java}
  
  <<<CriteriaTransferObjectConverter>>> uses the notion of property mapping groups to decide which mapping rules to apply for which CTO instance.
  
  <<<NestedPropertyCriteriaBasedConverter>>> is the default general purpose <<<CriteriaTransferObjectConverter>>> implementation that uses <<<NestedPropertyCriteria>>> as the server-side criteria
  implementation. <<<NestedPropertyCriteriaBasedConverter>>> acts as a map-based container for <<<NestedPropertyMappingGroup>>> instances, which in turn contain a map of <<<NestedPropertyMapping>>>
  instances for specific properties of the target persistent entity. <<<NestedPropertyCriteriaBasedConverter>>> tries to hide internal <<<NestedPropertyMappingGroup>>> processing away from the
  end-user via the <addMapping> method, which is a preferred way of configuring this CTO converter implementation.
  
  As you might guess, a <<<NestedPropertyMapping>>> is pretty essential for the <<<NestedPropertyCriteriaBasedConverter>>> in terms of its configuration. <<<NestedPropertyMapping>>> represents an
  abstract CTO mapping that supports a nested property of the target persistent entity (just like the <<<NestedPropertyCriterion>>> mentioned in the {{{./entity-criteria-api.html} previous section}}).
  <<<NestedPropertyMapping>>> defines a general relation between <<<CriteriaTransferObject>>> and <<<NestedPropertyCriteria>>> for a single property of the target persistent entity using the <propertyId>
  concept as shown above. Updating the server-side criteria instance according to client-side <<<FilterAndSortCriteria>>> is achieved via the abstract <apply> method (this one is called for each
  <<<NestedPropertyMapping>>> within a <<<NestedPropertyMappingGroup>>> during the CTO conversion):
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/cto-pattern-NestedPropertyMapping.java}
  
  <<<FilterAndSortMapping>>> is the default <<<NestedPropertyMapping>>> subclass that is intended for direct use in conjunction with <<<NestedPropertyCriteriaBasedConverter>>>. Presence of a custom
  <<<PropertyFilterCriterionProvider>>> implementation within the <<<FilterAndSortMapping>>> indicates the use of the filtering functionality (if not <null>, the given <<<PropertyFilterCriterionProvider>>>
  implementation will be used to construct a <<<FilterCriterion>>> instance to be added to the server-side criteria). However, the <<<FilterCriterion>>> instance will be added to the server-side criteria
  only in case the <<<FilterAndSortCriteria>>> contains at least one filter value.
  
  In order to resolve string-based filter values received from the corresponding <<<FilterAndSortCriteria>>> instance into their typed object representations, a custom <<<FilterValueObjectProvider>>>
  implementation needs to be provided as well (assuming the use of the filtering functionality):
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/cto-pattern-FilterValueObjectProvider.java}
  
  Note that all filter values converted via this interface will be passed as <directValues> to the underlying <<<FilterCriterion>>> instance - <<<NestedPropertyCriteriaBasedConverter>>>
  generally doesn't use the filter object concept since the structure and type of filter values within <<<FilterAndSortCriteria>>> make it too generic for it to be used correctly
  (remember that the filter object is efficient in applications where GUI changes can be seamlessly propagated to the server).
  
  As for the sorting functionality, no additional settings are necessary since the <<<FilterAndSortCriteria>>> instance contains all supported sort options by default. Note that the
  sorting functionality (underlying <<<SortCriterion>>> instance processing) can be turned off by setting <<<FilterAndSortCriteria>>>'s <sortAscending> property to <null>.
  
  Since the <<<CriteriaTransferObject>>> allows its users to define paging and sort criteria in addition to property filter constraints, converting such CTO instance directly into
  a <<<NestedPropertyCriteria>>> and passing it to <count> methods of your DAO classes might not work correctly for most databases. This is because <<<AbstractHibernateEntityDao>>>'s
  row count technique implementation relies on Hibernate <<<rowCount>>> projection (<<<AbstractHibernateEntityDao>>> uses <<<BaseHibernateDataAccessor>>>'s <rowCount> method under
  the hood for this purpose). The bottom line is that the target <<<Criteria>>> instance shouldn't contain any paging constraints since the <rowCount> method relies on a result set
  with its "shape" defined by the projection itself. The <<<rowCount>>> projection essentially results in <<<SELECT COUNT(*) FROM ...>>> SQL statement and we expect to receive exactly
  one integer value as its result (the shape of our projection). Adding paging constraints to such <<<Criteria>>> instance doesn't make much sense for projections since it restricts
  their elements (which is not what we want in general).
  
  So, how can we use CTO instances safely within the context of standard <count> methods? The answer is <<<CriteriaTransferObjectCountWrapper>>> - a simple server-side CTO wrapper
  designed for entity instance count purposes. <<<CriteriaTransferObjectCountWrapper>>> takes the original CTO instance as its argument and creates a new CTO which delegates most
  of its methods to the wrapped CTO instance with the exception of paging and sort constraints and methods that modify internal state of the transfer object:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/cto-pattern-CriteriaTransferObjectCountWrapperUsage.java}
  
* {Sample CTO converter}
  
  Let's build a sample CTO converter that demonstrates basic property mapping configuration. One way of doing this is to extend the <<<NestedPropertyCriteriaBasedConverter>>> class and
  provide property mappings within the implementation itself:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/cto-pattern-SampleCtoConverter.java}
  
  The <<<SampleConverter>>> contains a single mapping group that defines some property mappings for the fictional <<<Customer>>> entity (name, favorite number and join date). Things get
  usually far more complex than this, but basically this is the way how you would typically configure the <<<NestedPropertyCriteriaBasedConverter>>> instance. Note that the <enabled> method
  of the <<<PropertyFilterCriterionProvider>>> interface could be used for disabling filtering within the given <<<FilterAndSortMapping>>>, just like as in the sample <<<OrderDaoImpl>>> from
  the {{{./entity-criteria-api.html} previous section}}.
  
* {FAQ}
  
  We recommend browsing through the {{{./reference-faq.html} Reference Documentation FAQ}} for detailed information on related issues.
