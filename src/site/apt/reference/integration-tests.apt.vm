 ----
 Integration test support
 ----
 Vojtech Szocs
 ----
 18 March 2009
 ----

Integration test support
  
  Take advantage of an out-of-the-box integration test support to write your own custom integration tests for the database of your choice using the standard integration test infrastructure.
  
Sections
  
  * {{{./integration-tests.html#Overview} Overview}}
  
  * {{{./integration-tests.html#Introduction} Introduction}}
  
  * {{{./integration-tests.html#Standard_database_support} Standard database support}}
  
  * {{{./integration-tests.html#Integration_test_infrastructure_overview} Integration test infrastructure overview}}
  
  * {{{./integration-tests.html#DAO_versus_service} DAO versus service}}
  
  * {{{./integration-tests.html#Writing_a_custom_core_integration_test} Writing a custom core integration test}}
  
  * {{{./integration-tests.html#FAQ} FAQ}}
  
  []
  
External resources
  
  * {{{http://static.springframework.org/spring/docs/2.5.x/reference/testing.html#integration-testing} Spring TestContext framework}}
  
  * {{{http://www.mockobjects.com/} Mock objects}}
  
  []
  
* {Overview}
  
  * Project: <${df-test}>
  
  * Package reference: <<<com.anasoft.os.daofusion.test.*>>>
  
* {Introduction}
  
  Having a generic DAO pattern implementation with all of its handy features is nice, but how can one be sure that it works properly for a specific database? This is actually a quite
  important aspect since developers using ${df} need to feel "safe" when using the out-of-the-box DAO functionality. The basic idea behind the integration test support is to encourage
  developers to use ${df}, knowing that:
  
  * all standard DAO implementations are properly and thoroughly tested using a non-trivial sample domain model for all major databases (standard core integration tests)
  
  * it is possible to write custom integration tests for the chosen database using the standard integration test infrastructure (custom generic / core integration tests)
  
  []
  
  An integration test is basically a {{{http://en.wikipedia.org/wiki/Unit_testing} unit test}} interacting with a database instance via {{{http://java.sun.com/developer/technicalArticles/J2EE/jpa/} JPA}}
  / {{{http://www.hibernate.org/} Hibernate}}, employing a default method-level rollback strategy which ensures proper test data separation between multiple test runs. ${df} achieves this
  using {{{http://www.junit.org/} JUnit}} and {{{http://static.springframework.org/spring/docs/2.5.x/reference/testing.html#integration-testing} Spring TestContext framework}} in a consistent
  integration test infrastructure.
  
  Note that there are actually two kinds of integration tests:
  
  * <generic integration tests> - aimed at testing custom business-related DAO functionality
  
  * <core integration tests> - aimed at testing core DAO functionality within the standard DAO implementations (<<<AbstractHibernateEntityDao>>> and <<<AbstractHibernateEnumerationDao>>>), using a non-trivial sample domain model
  
  []
  
* {Standard database support}
  
  ${df} is currently integration-tested against the following databases:
  
  * In-memory databases
  
    * {{{http://www.h2database.com/} H2}} (1.0.79)
  
    * {{{http://hsqldb.org/} HSQL}} (1.8.0.10)
  
  []
  
  * Mid-scale databases
  
    * {{{http://www.mysql.com/} MySQL}} (5.1.30)
  
    * {{{http://www.postgresql.org/} PostgreSQL}} (8.3.5)
  
  []
  
  * Enterprise databases
  
    * {{{http://www.ibm.com/db2} DB2}} (9.5)
  
    * {{{http://www.oracle.com/technology/products/database/oracle10g/index.html} Oracle 10g}} (10.2.0.3.0)
  
    * {{{http://en.wikipedia.org/wiki/Microsoft_SQL_Server} MS SQL Server 2000}} (8.00.760)
  
  []
  
  This means that ${df} includes integration tests for databases listed above as part of unit tests within the <${df-test}> project. You are free to check out the <${df-test}> project
  from the {{{../source-repository.html} source code repository}} and run these tests by yourself. This is, however, not quite necessary since ${df}'s {{{../cont-integration.html} continuous integration}}
  system performs this task when building ${df} as well.
  
  To sum it up, <standard> core integration tests need not to be run manually - the <${df-test}> project is intended for use as a {{{http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#Dependency_Scope} test-scoped}}
  library dependency providing an integration test infrastructure for <custom> integration tests.
  
* {Integration test infrastructure overview}
  
  <<<BaseHibernateIntegrationTest>>> represents a generic integration test which is agnostic of the underlying database instance in use. <<<BaseHibernateIntegrationTest>>> uses the <<<SpringJUnit4ClassRunner>>>
  which provides functionality of the <Spring TestContext framework> to standard <JUnit> tests. <<<BaseHibernateIntegrationTest>>> declares two test execution listeners vital for integration tests
  (<<<DependencyInjectionTestExecutionListener>>> and <<<TransactionalTestExecutionListener>>>) along with the default method-level rollback strategy via the <<<TransactionConfiguration(defaultRollback = true)>>>
  annotation.
  
  <<<BaseHibernateIntegrationTest>>> defines its own Spring context location pointing to the parent context for all integration tests. This parent context contains everything necessary to set up the basic
  JPA / Hibernate test environment, including the following components:
  
  * <<<com.mchange.v2.c3p0.ComboPooledDataSource>>> as the pooled data source providing database access via JDBC
  
  * <<<org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean>>> as the JPA entity manager factory wrapper that uses <<<org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter>>> as its JPA vendor adapter
  
  * <<<org.springframework.orm.jpa.JpaTransactionManager>>> as the transaction manager for JPA entity manager factory
  
  * <<<org.springframework.transaction.interceptor.TransactionInterceptor>>> as the AOP transaction interceptor for declarative transaction management, using <<<org.springframework.transaction.annotation.AnnotationTransactionAttributeSource>>>
    for specifying transaction metadata via annotations
  
  * proxy-based JPA / AOP transaction annotation support which includes the <<<org.springframework.orm.jpa.support.PersistenceAnnotationBeanPostProcessor>>>
  
  []
  
  In order to make specific integration tests work properly, some additional configuration steps need to be performed:
  
  * Following Spring bean properties need to be set up via the <<<PropertyOverrideConfigurer>>> according to the database instance in use:
  
    * <<<dataSource.driverClass>>>
  
    * <<<dataSource.jdbcUrl>>>
  
    * <<<dataSource.user>>>
  
    * <<<dataSource.password>>>
  
    * <<<entityManagerFactory.persistenceUnitName>>>
  
  []
  
  * Within the <<<META-INF/persistence.xml>>> file a dedicated integration test persistence unit of type <<<RESOURCE_LOCAL>>> needs to be defined for the target database instance. Name of this
    persistence unit must match the <<<entityManagerFactory.persistenceUnitName>>> bean property value. The <<<hibernate.dialect>>> property needs to be set up as well within the persistence unit.
  
  []
  
  * Additional persistence unit configuration (e.g. defining entity mappings or setting the default schema name) should be done via the <<<mapping-file>>> element(s) within <<<META-INF/persistence.xml>>>.
  
  []
  
  <<<BaseHibernateIntegrationTest>>> introduces a test profile convention for local and remote databases which is aimed at running fine-grained integration tests. Assume that the application
  includes several custom integration tests for local and remote databases: a local database installed on developer's machine and a remote database reachable from the company's continuous
  integration system. It's convenient for the developer to run integration tests locally before commiting his changes. On the other hand, the continuous integration system can run integration
  tests against the remote database dedicated for this purpose (note that it is highly recommended that the remote database is of the same type and version as the "real" production one). See
  the <<<BaseHibernateIntegrationTest>>> Javadoc for more information about the test profile convention as well as other useful hints.
  
  <<<BaseHibernateCoreIntegrationTest>>> is an extension of the <<<BaseHibernateIntegrationTest>>> for core integration tests aimed at standard persistent entity DAO implementations. Core integration
  tests operate on the sample <eShop> domain model defined within the <<<example>>> subpackage, including persistent entity and enumeration classes as well as corresponding DAO implementations.
  <<<BaseHibernateCoreIntegrationTest>>> is actually a base class for core integration tests - all of the configuration details mentioned above still applies to its subclasses. The main purpose
  of <<<BaseHibernateCoreIntegrationTest>>> is to define dependency on sample <eShop> domain classes as well as preparing initial test data to be shared by all test cases.
  
  There are two abstract core integration test classes derived from <<<BaseHibernateCoreIntegrationTest>>> for the two standard DAO implementations: <<<AbstractHibernateEntityDaoTest>>> and
  <<<AbstractHibernateEnumerationDaoTest>>>. These classes contain the actual test code exercising on sample DAO implementations. Since they are abstract, the user needs to extend and configure
  them for a specific database instance.
  
  As for custom generic integration tests aimed at testing business-related DAO functionality, you should extend the <<<BaseHibernateIntegrationTest>>> directly and provide all the configuration
  details regarding target database instance(s). The best way to start writing such integration tests is to examine the integration test infrastructure and the way how standard core
  integration tests use it in detail.
  
* {DAO versus service}
  
  Assuming that you follow the general {{{http://en.wikipedia.org/wiki/Multitier_architecture} multi-tier client-server architecture}} within your application, there are a couple of things that
  set the DAO and service layers apart from each other:
  
  * business-related DAO functionality should always be atomic from a persistent entity point of view, for example:
  
    * entity lookup based on custom business criteria that comes from a specific use case scenario regarding that entity
  
  []
  
  * everything else performing complex business operations (most typically encompassing multiple persistent entities) should be implemented within the service layer, for example:
  
    * operation that validates the input, creates multiple entities (including their associations) and persists them into the database
  
  []
  
  Notice that the service layer doesn't need integration tests assuming the DAO functionality itself is integration-tested - a service is, after all, just using the DAO to perform
  complex business operations. A general rule of thumb here is to use the {{{http://www.mockobjects.com/} mock object}} approach for unit-testing the service layer in a way that
  abstracts from the data access and puts real focus to the actual business problem.
  
* {Writing a custom core integration test}
  
  So, you have your own specific database for which you want to test the core DAO functionality using the standard integration test infrastructure. First thing you need to do is to
  extend <<<AbstractHibernateEntityDaoTest>>> / <<<AbstractHibernateEnumerationDaoTest>>> like this:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/integration-tests-CustomCoreIntegrationTest-TestClass.java}
  
  In this case, <<<DatabaseContextLocations.POSTGRESQL>>> should point to a Spring context for a local PostgreSQL database instance:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/integration-tests-CustomCoreIntegrationTest-SpringContext.xml}
  
  The <<<test-postgresql-beanSetup.properties>>> file referenced by this context would look like this:
  
%{code-snippet|brush=java-properties|file=src/site/snippet/reference/integration-tests-CustomCoreIntegrationTest-SpringSetup.properties}
  
  Since JPA uses <<<META-INF/persistence.xml>>> as the default persistence metadata descriptor, you need to provide this file as well:
  
%{code-snippet|brush-autodetect=1|file=src/site/snippet/reference/integration-tests-CustomCoreIntegrationTest-Persistence.xml}
  
  How cool is that? Using the standard integration test infrastructure that sets up the JPA / Hibernate test environment, we are able to write custom core integration tests with
  only a few lines of Java code and configuration. Notice that we're using the <<<test-core-orm.xml>>> file defining entity mappings for the sample <eShop> domain model.
  
* {FAQ}
  
  We recommend browsing through the {{{./reference-faq.html} Reference Documentation FAQ}} for detailed information on related issues.
