 ----
 Persistent entity model
 ----
 Vojtech Szocs
 ----
 26 February 2009
 ----

Persistent entity model
  
  Model your business domain using a standard persistent entity model with out-of-the-box default persistent entity implementations.
  
Sections
  
  * {{{./entity-model.html#Overview} Overview}}
  
  * {{{./entity-model.html#Introduction} Introduction}}
  
  * {{{./entity-model.html#Persistent_entity_model_overview} Persistent entity model overview}}
  
  * {{{./entity-model.html#Implementing_hashCode__equals_synthetic_generated_value_approach} Implementing hashCode and equals (synthetic generated value approach)}}
  
  * {{{./entity-model.html#Sample_persistent_entity} Sample persistent entity}}
  
  * {{{./entity-model.html#Sample_persistent_enumeration} Sample persistent enumeration}}
  
  * {{{./entity-model.html#FAQ} FAQ}}
  
  []
  
External resources
  
  * {{{http://java.sun.com/javaee/5/docs/tutorial/doc/bnbpz.html} JPA Java EE 5 tutorial}}
  
  []
  
* {Overview}
  
  * Project: <${df-core}>
  
  * Package reference: <<<com.anasoft.os.daofusion.entity>>>
  
* {Introduction}
  
  Development of a DAO layer for a specific project usually starts out with the task of domain model definition. You can think of a domain model as a description of the business
  problem in terms of entities and their relations. Domain model definition phase usually comes after collecting business requirements for the given project, most typically in some
  form of business analysis using notations such as {{{http://en.wikipedia.org/wiki/Unified_Modeling_Language} UML}}.
  
  Having the domain model defined, the next logical step is to implement it in Java via persistent entities. Persistent entities are classes that implement entities of the business
  problem which are intended to be stored within the underlying database.
  
  Each persistent entity follows a standard lifecycle as declared by the {{{http://java.sun.com/developer/technicalArticles/J2EE/jpa/} JPA}} specification:
  
  * After its creation, the entity starts out in the <transient> state. Being transient means that it is not managed within the persistence context yet. Transient instances have
    usually some properties set by the user before their persistence.
  
  * Persisting a transient entity results in associating the entity with the persistence context and saving it into the database, according to transaction boundaries and associated
    flush mode. From now on, the entity is being managed within the current persistence session - it's in the <attached> state.
  
  * When the associated persistence session ends or an entity gets evicted from the current session, it is treated as <detached>. A detached entity needs to be reattached to the
    current persistence context in order to use persistence services again.
  
* {Persistent entity model overview}
  
  ${df} provides a standard persistent entity model with out-of-the-box default implementations for you to build on.
  
  <<<Persistable>>> interface represents a generic persistent entity contract using single primary key column type as the class parameter. This parameter is used by the <<<PersistentEntityDao>>>
  when querying for entities by their id's and is therefore mandatory. However, this doesn't mean that users cannot define custom primary keys in their entities - see the
  <<<Persistable>>> Javadoc for more information about simple and composite primary key approaches as well as other useful hints. As for the inheritance mapping strategy, it is up to the
  user to mark specific root nodes within the persistent entity hierarchy via the <<<Inheritance>>> annotation as appropriate (keep in mind that the default JPA inheritance strategy is set
  to <single table per class> along with its implications on the underlying database schema).
  
  <<<PersistentEntity>>> is an abstract implementation of the <<<Persistable>>> interface for an entity managed within the JPA persistence context. It defines an automatically-generated id field
  of the given type using the <<<Id>>> and <<<GeneratedValue>>> annotations. Note that the <<<PersistentEntity>>> does NOT provide any special <hashCode> / <equals> method implementation - this is a task
  left to be done by the user, depending on the chosen method implementation pattern. See the <<<Persistable>>> Javadoc for more information about the two basic implementation patterns and
  their comparison (business key versus synthetic generated value approach).
  
  There are two specialized abstract classes derived from <<<PersistentEntity>>> which use <<<Long>>> as the primary key column type: <<<MutablePersistentEntity>>> and <<<ImmutablePersistentEntity>>>.
  
  <<<MutablePersistentEntity>>> features the version-based {{{http://en.wikipedia.org/wiki/Optimistic_locking} optimistic locking strategy}} support via a version field and is generally
  recommended for standard mutable domain-specific objects.
  
  <<<ImmutablePersistentEntity>>> is marked as <<<Immutable>>> so that any updates performed by Hibernate on this entity will be silently ignored. You can use this entity class for domain-specific
  objects which are not allowed to be changed after their persistence.
  
  Last but not least, <<<PersistentEnumeration>>> as an extension of the <<<PersistentEntity>>> using <<<Long>>> as the primary key column type is suitable for situations when you need dynamic
  enumerations to be stored within the database. <<<PersistentEnumeration>>> contains a name field with unique, not-updatable and not-null constraints which can be used by the
  <<<PersistentEnumerationDao>>> for string-based enumeration lookup. Unlike <<<PersistentEntity>>>, <<<PersistentEnumeration>>> provides the <hashCode> / <equals> method implementation based
  on the name field. Note that the <<<PersistentEnumeration>>> does not contain a version field like <<<MutablePersistentEntity>>> does - users can add this field in enumeration subclasses
  on their own if they require version-based optimistic locking strategy support.
  
* {Implementing <hashCode> / <equals> (synthetic generated value approach)}
  
  Implementing <hashCode> / <equals> methods correctly can be sometimes very tricky and can lead to strange errors regarding the application behavior. As mentioned above,
  there are basically two approaches to their implementation. The following code demonstrates the synthetic generated value approach based on the <<<UUID>>> class:
  
+-----+
@MappedSuperclass
public abstract class OidBasedMutablePersistentEntity extends MutablePersistentEntity {

    @NaturalId
    @Column(length = 36, name = "object_id", unique = true, updatable = false, nullable = false)
    private String oid;

    public OidBasedMutablePersistentEntity() {
        oid = UUID.randomUUID().toString();
    }

    public String getOid() {
        return oid;
    }

    protected void setOid(String oid) {
        this.oid = oid;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((oid == null) ? 0 : oid.hashCode());
        return result;
    }

    @Override
    public final boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (!(obj instanceof OidBasedMutablePersistentEntity)) {
            return false;
        }

        final OidBasedMutablePersistentEntity other = (OidBasedMutablePersistentEntity) obj;

        return oid.equals(other.oid);
    }

}
+-----+
  
  Note that the <oid> field setter is marked as protected to avoid direct object identity manipulation.
  
* {Sample persistent entity}
  
  The following code shows a sample persistent entity, extending the <<<OidBasedMutablePersistentEntity>>> class as shown above:
  
+-----+
@Entity
@Table(name = "orders")
public class Order extends OidBasedMutablePersistentEntity {

    @Column(nullable = false, updatable = false)
    @Temporal(TemporalType.TIMESTAMP)
    private Date creationDate;

    @Embedded
    private Address shippingAddress;

    @OneToMany(mappedBy = "order")
    @Cascade(value = {CascadeType.SAVE_UPDATE})
    private List<OrderItem> orderItems = new ArrayList<OrderItem>();

    @Column(nullable = false)
    private Boolean complete;

    @ManyToOne
    @JoinColumn(nullable = false, updatable = false)
    private Customer customer;

    protected List<OrderItem> getOrderItems() {
        return orderItems;
    }

    protected void setOrderItems(List<OrderItem> orderItems) {
        this.orderItems = orderItems;
    }

    public void addOrderItem(OrderItem orderItem) {
        orderItems.add(orderItem);
        orderItem.setOrder(this);
    }

    public void removeOrderItem(OrderItem orderItem) {
        orderItems.remove(orderItem);
        orderItem.setOrder(null);
    }

    public List<OrderItem> getUnmodifiableOrderItemList() {
        return Collections.unmodifiableList(orderItems);
    }

    // rest of the getters and setters go here

    public int getTotalPrice() {
        int result = 0;

        for (OrderItem orderItem : orderItems) {
            result += orderItem.getTotalPrice();
        }

        return result;
    }

}
+-----+
  
  As you can see, there is nothing special happening here except that we are extending the <<<OidBasedMutablePersistentEntity>>> class which implements the synthetic generated value approach.
  
  Note that the getter and setter for the <orderItems> field are marked as protected to avoid direct list manipulation - <<<OneToMany(mappedBy = "order")>>> annotation defines a 1:N bidirectional
  relationship between <<<Order>>> and <<<OrderItem>>> classes. Instead, there are two public methods which handle the bidirectional relationship properly and are intended to be used for the <orderItems>
  list manipulation (<addOrderItem> and <removeOrderItem>). Last but not least, the <getUnmodifiableOrderItemList> method returns an unmodifiable list of <<<OrderItem>>> instances for inspecting
  <orderItems> list values in a read-only fashion.
  
  Our sample persistent entity contains one extra method performing a simple business logic (calculating the total price of an order). The general rule of thumb here is to put all
  the major business logic into the service layer to avoid entity classes getting messed up with logic and tight coupling over time. However, for the most simple cases such as this
  one, this is an acceptable solution.
  
* {Sample persistent enumeration}
  
  The following code shows a sample persistent enumeration:
  
+-----+
@Entity
@Table(name = "payment_types")
public class PaymentType extends PersistentEnumeration {

    // place some custom code here

}
+-----+
  
  You could add an extra description field to the enumeration class if necessary but basically that's all about it.
  
* {FAQ}
  
  We recommend browsing through the {{{./reference-faq.html} Reference Documentation FAQ}} for detailed information on related issues.
